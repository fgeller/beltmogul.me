#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="/css/normalize.css" />
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="/css/styles.css" />
#+HTML_HEAD: <link type="text/css" rel="stylesheet" href="http://fonts.googleapis.com/css?family=Raleway:100,400,600"/>
#+HTML_HEAD: <link type="text/css" rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lato"/>
#+HTML_HEAD: <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
#+HTML_HEAD: <link rel="icon" href="/favicon.ico" type="image/x-icon">
#+HTML_HEAD: <link href="atom.xml" type="application/atom+xml" rel="alternate" title="belt mogul feed">
#+HTML_HEAD: <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
#+OPTIONS: html-link-use-abs-url:nil html-postamble:nil html-preamble:nil
#+OPTIONS: html-scripts:nil html-style:nil html5-fancy:nil
#+OPTIONS: toc:0 num:nil ^:{}
#+HTML_CONTAINER: div
#+HTML_DOCTYPE: xhtml-strict
#+TITLE: belt mogul

#+BEGIN_HTML
<a href="/atom.xml" class="fa fa-rss"></a>
#+END_HTML

* § [[file:2014/clojure-workflow.html][clojure workflow]]

  This post is a write-up of a short presentation that I gave at the last Clojure
meetup in Auckland. The topic was "Real World Clojure" and I gave a quick demo
of the interactive workflow that I enjoyed for my last side projects. For the
demo, I used [[http://clojure-liberator.github.io/liberator/][Liberator]] to implement basic GET and POST operations against a
=/users= resource and [[http://www.datomic.com/][Datomic]] for storage. But a fair warning: there isn't much
detail about either one of those two technologies in my post. My focus was on
the interactive workflow that I enjoy so much about LISPs. Both Liberator and
Datomic are well documented, perhaps this post gets you interested in
either.

* Setup

  The setup is just Emacs with [[https://github.com/clojure-emacs/cider][clojure-emacs/cider]] and a [[http://leiningen.org/][Leiningen]] project. No
  special configuration on the Emacs side, and I pushed the project template
  with tests and a basic Datomic setup to [[https://github.com/fgeller/clj-meetup-akl-2014-08][fgeller/clj-meetup-akl-2014-08]].

  Luckily, the project contains basic tests for the HTTP interface:

  #+begin_src clojure
    (fact "listing users"
          (let [response (handlers (request :get "/users"))]
            (:status response) => 200
            (:body response) => "{}")
          (cleanup))
    (fact "adding and listing a user"
          (let [request (body (content-type (request :post "/users") "application/json") "{\"nick\": \"hans\"}")
                response (handlers request)]
            (:status response) => 201)
          (let [response (handlers (request :get "/users"))]
            (:status response) => 200
            (:body response) => "{\"1\":{\"nick\":\"hans\"}}")
          (cleanup))
  #+end_src

  The tests are written with [[https://github.com/marick/Midje][marick/Midje]] and outline the basic requirements for
  this example. For test feedback, I use =eshell= and Leiningen to start a REPL
  via =(compile "lein repl" t)= in the project root. Midje includes support for
  triggering test runs on file change, so let's load that up:

  #+ATTR_HTML: :alt Midje to run tests :title Midje to run tests
  [[file:../../img/o/Screen-Shot-2014-08-31-at-12.32.52-PM.png][file:../../img/o/Screen-Shot-2014-08-31-at-12.32.52-PM-resized.png]]

  Let's take a quick look at the template (=src/meetup-users/core.clj=). Basic
  namespacing and imports to get started:

  #+begin_src clojure
    (ns meetup-users.core
      (:require
       [clojure.data.json :as json]
       [clojure.java.io :as io]
       [datomic.api :only [q db] :as peer]
       [liberator.core :refer [resource defresource]]
       [liberator.dev :refer [wrap-trace]]
       [compojure.core :refer [defroutes ANY]]
       [ring.adapter.jetty :refer [run-jetty]]))
  #+end_src

  Define where to find Datomic and how we layout our data:

  #+begin_src clojure
    (def datomic-uri "datomic:mem://users")
    (def schema-txs [{:db/id #db/id[:db.part/db]
                      :db/ident :user/id
                      :db/valueType :db.type/long
                      :db/cardinality :db.cardinality/one
                      :db.install/_attribute :db.part/db},
                     {:db/id #db/id[:db.part/db]
                      :db/ident :user/nick
                      :db/valueType :db.type/string
                      :db/cardinality :db.cardinality/one
                      :db.install/_attribute :db.part/db}])

  #+end_src

  The URI defines that we're not going to persist our data for now and just use
  the in-memory storage for a database name =users=. The =schema-txs= hold the
  transactions to describe user entities. We define two attributes =:user/id= and
  =:user/nick=, the =:user/id= will be the external ID, rather than exposing the
  internal entity ID. To read more about the structure of these transactions,
  you can get started [[http://docs.datomic.com/transactions.html][here]].

  Then some wrappers around Datomic's API to make testing a bit easier:

  #+begin_src clojure
    (defn setup-database []
      (peer/create-database datomic-uri)
      @(peer/transact (peer/connect datomic-uri) schema-txs))
    (defn delete-database []
      (peer/delete-database datomic-uri))
    (defn read-database []
      (peer/db (peer/connect datomic-uri)))
    (setup-database)
  #+end_src

  This will be the starting point, an empty resource definition:

  #+begin_src clojure
    (defresource users-resource)
  #+end_src

  The following hooks the resource into the default ring setup and defines a
  helper to start up the application using jetty:

  #+begin_src clojure
    (defroutes app-routes (ANY "/users" [] users-resource))
    (def handlers (wrap-trace app-routes :header :ui))
    (defn boot [port] (run-jetty #'handlers {:port port :join? false}))
  #+end_src

  The =wrap-trace= middleware is provided by Liberator to make debugging easier,
  will see it's output shortly.

* Let's get started

  We can see that all tests fail, and the easiest target seems to be the GET
  request. So let's fake that one by returning an empty map:

  #+begin_src clojure
    (defresource users-resource
      :handle-ok (fn [context] {}))
  #+end_src

  But the test results aren't very helpful, we're just getting 500s:

  #+ATTR_HTML: :alt Test failures :title Test failures
  [[file:../../img/o/Screen-Shot-2014-08-31-at-1.28.17-PM.png][file:../../img/o/Screen-Shot-2014-08-31-at-1.28.17-PM-resized.png]]

  So let's use Liberator to figure this out. Make sure you started cider via
  =cider-jack-in=, which starts a headless REPL that we can use for evaluating our
  code. Evaluating the =core.clj= buffer via =cider-eval-buffer= allows for starting
  the application on port 2134 via =(boot 2134)=. Just add the expression in your
  buffer and evaluate it via =C-x C-e= (with point after the expression). Your
  minibuffer should show some feedback that the expression was evaluated, in my
  case:

  #+begin_src text
    => #<Server org.eclipse.jetty.server.Server@6df54136>
  #+end_src

  Don't forget to remove the expression once you're done, or you'll get warnings
  as you tests run in the background.

  Now create or change to an eshell buffer to query the application. Issue a
  request via =curl -v localhost:2134/users=, this is my result:

  #+ATTR_HTML: :alt Curl output :title Curl output
  [[file:../../img/o/Screen-Shot-2014-08-31-at-1.43.32-PM.png][file:../../img/o/Screen-Shot-2014-08-31-at-1.43.32-PM-resized.png]]

  You can see the result of adding the =wrap-trace= middleware: We're getting
  feedback on the decisions that Liberator took for our request. The first check
  is whether the service is available, then if the request's method is known and
  so on. It seems to find no available media types:

  #+begin_src text
< X-Liberator-Trace: :decision (:media-type-available? nil)
< X-Liberator-Trace: :handler (:handle-not-acceptable "(default implementation)")
  #+end_src

  Before we change that, the following lines give you a link to a visual
  representation of the decision graph:

  #+begin_src text
< Link: <//x-liberator/requests/4eo3a>; rel=x-liberator-trace
< X-Liberator-Trace-Id: 4eo3a
  #+end_src

  You can open the request in your browser and follow the colored path to figure
  out what happened. In my case the URL is http://localhost:2134/x-liberator/requests/4eo3a

  #+ATTR_HTML: :alt Decision graph :title Decision graph
  [[file:../../img/o/Screen-Shot-2014-08-31-at-1.53.12-PM.png][file:../../img/o/Screen-Shot-2014-08-31-at-1.53.12-PM-resized.png]]

  To make the media type avaible, we just add:

  #+begin_src clojure
    (defresource users-resource
      :available-media-types ["application/json"]
      :handle-ok (fn [context] {}))
  #+end_src

  Now we only have the POST functionality left ;)

  #+ATTR_HTML: :alt Decision graph. :title Decision graph.
  [[file:../../img/o/Screen-Shot-2014-08-31-at-1.56.01-PM.png][file:../../img/o/Screen-Shot-2014-08-31-at-1.56.01-PM-resized.png]]

  Let's give that a try and take a look at the data we're given:

  #+begin_src clojure
(defresource users-resource
  :available-media-types ["application/json"]
  :post! (fn [context] (println context))
  :handle-ok (fn [context] {}))
  #+end_src

  But the POST request is failing with a 405. If you don't know all status codes
  by heart, like me, just evaluate the buffer again (or just the =defresource=
  expression) and issue another request via:

  #+begin_src fundamental
    curl -v -XPOST -H'Content-type: application/json' -d'{"nick": "hans"}' localhost:2134/users
  #+end_src

  And Liberator will tell us:

  #+ATTR_HTML: :alt Method not allowed. :title Method not allowed.
  [[file:../../img/o/Screen-Shot-2014-08-31-at-2.05.26-PM.png][file:../../img/o/Screen-Shot-2014-08-31-at-2.05.26-PM-resized.png]]

  So let's allow that method:

  #+begin_src clojure
(defresource users-resource
  :available-media-types ["application/json"]
  :allowed-methods [:get :post]
  :post! (fn [context] (println context))
  :handle-ok (fn [context] {}))
  #+end_src

  And there we have our request context:

  #+ATTR_HTML: :alt Request context. :title Request context.
  [[file:../../img/o/Screen-Shot-2014-08-31-at-2.07.28-PM.png][file:../../img/o/Screen-Shot-2014-08-31-at-2.07.28-PM-resized.png]]

  And the POST test succeeds as well! ;) So let's stop faking and actually pass
  the data on to Datomic:

  #+begin_src clojure
    (defn find-all-users [database]
      (peer/q '[:find ?u :where [?u :user/id]] database))

    (defn add-user [database data]
      (let [new-id (+ 1 (count (find-all-users database)))
            user-tx {:db/id (peer/tempid :db.part/user) :user/id new-id :user/nick (get data "nick")}]
        (println
         (peer/transact (peer/connect datomic-uri) [user-tx]))))

    (defresource users-resource
      :available-media-types ["application/json"]
      :allowed-methods [:get :post]
      :post! (fn [context] (let [body (json/read-str (slurp (get-in context [:request :body])))]
                             (add-user (read-database) body)))
      :handle-ok (fn [context] {}))
  #+end_src

  This snippet skips several iterations where I use cider's backend for
  =eldoc-mode= to get a function's interface in the minibuffer or just use =println=
  on an intermediary result, like the result of the call to =peer/transact= above:

  #+ATTR_HTML: :alt Transaction result. :title Transaction result.
  [[file:../../img/o/Screen-Shot-2014-08-31-at-2.24.52-PM.png][file:../../img/o/Screen-Shot-2014-08-31-at-2.24.52-PM-resized.png]]

  The output shows me that the result is a future that I should probably wait
  for. So let's skip ahead once more and try an actual implementation of GET:

  #+begin_src clojure
    (defresource users-resource
      :available-media-types ["application/json"]
      :allowed-methods [:get :post]
      :post! (fn [context] (let [body (json/read-str (slurp (get-in context [:request :body])))]
                             (add-user (read-database) body)))
      :handle-ok (fn [context]
                   (let [database (read-database)
                         entity-ids (find-all-users database)]
                     entity-ids)))
  #+end_src

  Just returning the =entity-ids= doesn't work, we're getting 500s. Evaluating the
  buffer and firing another GET request via curl will tell us that the check
  against =multiple-representations?= fails and the request ends in a default
  implementation of =handle-exception=:

  #+begin_src fundamental
    < X-Liberator-Trace: :decision (:multiple-representations? false)
    < X-Liberator-Trace: :handler (:handle-ok)
    < X-Liberator-Trace: :handler (:handle-exception "(default implementation)")
  #+end_src

  So let's override that default implementation and take a look at the exception
  by printing it:

  #+begin_src clojure
    (defresource users-resource
      :handle-exception (fn [context] (println "EX:" (:exception context)))
      :available-media-types ["application/json"]
      :allowed-methods [:get :post]
      :post! (fn [context] (let [body (json/read-str (slurp (get-in context [:request :body])))]
                             (add-user (read-database) body)))
      :handle-ok (fn [context]
                   (let [database (read-database)
                         entity-ids (find-all-users database)]
                     entity-ids)))
  #+end_src

  We're getting a:

  #+begin_src fundamental
    EX: #<IllegalArgumentException java.lang.IllegalArgumentException: No implementation of method: :as-response of protocol: #'liberator.representation/Representation found for class: java.util.HashSet>
  #+end_src

  So there's no default implementation for serializing a HashSet to JSON. But
  that's ok, we only want to return a map, which is supported out of the
  box. So let's ignore that for now and built up our result:

  #+begin_src clojure
    (defresource users-resource
      :handle-exception (fn [context] (println "EX:" (:exception context)))
      :available-media-types ["application/json"]
      :allowed-methods [:get :post]
      :post! (fn [context] (let [body (json/read-str (slurp (get-in context [:request :body])))]
                             (add-user (read-database) body)))
      :handle-ok (fn [context]
                   (let [database (read-database)
                         entity-ids (find-all-users database)
                         entities (map (fn [[entity-id]] (peer/entity database entity-id))
                                       entity-ids)
                         users (map (fn [entity] {(:user/id entity) {:nick (:user/nick entity)}})
                                    entities)]
                     (into {} users))))
  #+end_src

  Our query against Datomic returns a vector of vectors, where each nested
  vector contains just the entity (identified by the =?u= in the query). We need
  to ask the database for the entity's information and then in the second =map=,
  create a list of maps where a user's external ID identifies a map of the
  user's attributes. In this case just the nick. Then we flatten the list into a
  single map with =into= and we're done, as Midje's test runner is happy ;)

  #+ATTR_HTML: :alt Done. :title Done.
  [[file:../../img/o/Screen-Shot-2014-08-31-at-2.36.37-PM.png][file:../../img/o/Screen-Shot-2014-08-31-at-2.36.37-PM-resized.png]]

* § [[file:2014/typing.html][typing]]

   This post is a summary of the tools that I'm fiddling with to tweak my
   keyboard layout every now and then. I recently changed from [[https://en.wikipedia.org/wiki/Dvorak_Simplified_Keyboard][Dvorak]] to the
   less standard [[http://www.workmanlayout.com/blog/][Workman Layout]] with a bit more exotic features that led me to
   look into options for implementing and customizing the layout.

* OSX

   For my Macbook, new layouts can be added by creating a bundle in
   =~/Library/Keyboard Layouts=. There is a Workman bundle with several layout
   variations available at [[https://github.com/deekayen/workman/tree/master/mac][deekayen/workman]]. I'm using a variation of [[https://github.com/deekayen/workman/tree/master/mac#workman-dead-for-programmers][Workman
   Dead]], which trades the number of key presses against the distance
   traveled. Additionally, you don't have to press a modifier key to get to the
   symbols. Symbols that are usually available via the number row, are
   accessible on home row after pressing the dead key. Pressing the dead key, in
   my case the comma key, will remap several keys. It changes the layout from
   normal Workman:

   #+ATTR_HTML: :alt workman layer. :title workman layer.
   [[file:../../img/o/Screen-Shot-2014-08-09-at-7.45.47-AM.png][file:../../img/o/Screen-Shot-2014-08-09-at-7.45.47-AM-resized.png]]

   to a more symbol focused one:

   #+ATTR_HTML: :alt symbol layer. :title symbol layer.
   [[file:../../img/o/Screen-Shot-2014-08-09-at-7.45.52-AM.png][file:../../img/o/Screen-Shot-2014-08-09-at-7.45.52-AM-resized.png]]

   For example, the key ={= is accessible by pressing
   @@html:<code>@@,s@@html:</code>@@ in succession, rather than =shift= + =[=, the
   key =(= is @@html:<code>@@,h@@html:</code>@@ rather than =shift= + =9= and so on.

   The symbol layer is different from the one included in the bundle at
   [[https://github.com/deekayen/workman/tree/master/mac][deekayen/workman]], more customized to my habits. For example, rather than
   splitting parentheses across both hands, I moved them to the left hand. This
   means that the right hand can stay on top of the dead key in case I want to
   insert a pair. I also traded numbers for more symbols and added =~= close to
   the dead key so that I can type =~/= conveniently in a rolling motion.

   The customization is quite straight forward with [[http://scripts.sil.org/cms/scripts/page.php?site_id%3Dnrsi&id%3Dukelele][Ukelele]]. You can open the
   main bundle, select the layout you want to modify and enter the symbol layer
   to modify just that part of it. Ukelele then updates the file that describes
   the layout (=*.keylayout= in =Workman.bundle/Contents/Resources=). Much more
   convenient than editing the XML by hand :)

  For some specific key remapping on my Macbook I use [[https://pqrs.org/osx/karabiner/][Karabiner]] and [[https://pqrs.org/osx/karabiner/seil.html.en][Seil]], rather
  than the layout. For example, capslock and return are both mapped to control
  when pressed in combination with another key, otherwise to their original
  meaning. The combination of Karabiner and Seil allows all sorts of
  remappings. For example, in the firmware version I mapped backslash to the
  capslock key, as I don't really use capslock. I use Seil to map capslock to
  backslash and Karabiner to map backslash to control when pressed in
  combination with another key.

  You can do this for any other key combo: Identify the key's code via:
  Karabiner > Misc & Uninstall > Launch EventViewer and use Seil to map the
  capslock key to that code. Then add your own configuration to Karabiner,
  similar to the following:

   #+begin_src xml
     <?xml version="1.0"?>
     <root>
       <item>
         <name>Change backslash to left control key.</name>
         <appendix>(Send an backslash key event when backslash key is pressed alone.)</appendix>
         <identifier>private.backslash_to_control_escape</identifier>

         <autogen>
           __KeyOverlaidModifier__
           <!-- from -->
           KeyCode::BACKSLASH,
           <!-- to -->
           KeyCode::CONTROL_L,
           <!-- alone -->
           KeyCode::BACKSLASH,
         </autogen>
       </item>
     </root>
   #+end_src

   The software support that OSX offers is quite convenient and switching
   between layouts is fast, in case someone else needs to type. But there are
   some shortcomings:

   - OSX defaults back to QWERTY when requesting an admin password or when
     logging out.

   - There are some issues with the symbol layers when using sites like
     [[http://www.keybr.com/][keybr.com]] or [[https://typing.io/][typing.io]] for practicing. Not sure where the key presses are
     lost or whether they are translated incorrectly.

   - When pairing with other developers, I fall back to Qwerty as Workman is
     still quite niche and few systems support it out of the box.

* ErgoDox

   Hardware to the rescue! I bought an [[http://ergodox.org/][ErgoDox]] via [[https://www.massdrop.com/buy/ergodox?s%3Dergodox][Massdrop]] last year and this
   seemed like the perfect opportunity to learn about its firmware. Compiling my
   own firmware version addresses the above issues by "escaping" OSX and
   allowing me to just plug in a keyboard with Workman installed. There are
   multiple firmware implementations available and I just customized one to fit
   my needs. This means custom placement of modifier keys and also adding the
   dead key layer. I'm using Massdrop's configurator for the ErgoDox to get a
   visual representation of my setup:

   #+ATTR_HTML: :alt ergodox layer 0. :title ergodox layer 0.
   [[file:../../img/o/ergodox-layer-0.png][file:../../img/o/ergodox-layer-0-resized.png]]

   This is just the first layer, the next layer is for symbols and the third is
   for a numpad on the right hand near home row, the full configuration is
   available [[https://www.massdrop.com/ext/ergodox/?referer%3D92TGQH&hash%3Dcd06f0925f6a7563b492b5fcfb08f7a7][here]].

   The configurator allows you to compile your own firmware version as well, but
   currently there is no support for the dead key approach that I'm using. But
   luckily [[https://github.com/benblazak/ergodox-firmware][benblazak/ergodox-firmware]] has support for sticky keys, which you can
   use to implement the dead key approach. The project is well documented and
   it's quite straight-forward to compile your own version on a Mac. The only
   external dependency I had to download was the compiler as part of the [[http://www.obdev.at/products/crosspack/download.html][AVR
   MacPack]]. Change the layout in =src/makefile-options= to your target and you're
   good to go! Simply issue a =make= in the =src= sub-folder and then load the
   resulting =firmware.hex= with a [[http://pjrc.com/teensy/loader_mac.html][Teensy Loader]] onto your ErgoDox.

   To implement a Workman Dead version, I used the existing [[https://github.com/benblazak/ergodox-firmware/blob/master/src/keyboard/ergodox/layout/colemak-jc-mod.c][Colemak layout]] that
   makes use of the sticky keys functionality and adapted the keys to
   Workman. The layout definition is split across three function invocations,
   where each one looks similar to the following:

   #+begin_src c
     const uint8_t PROGMEM _kb_layout[KB_LAYERS][KB_ROWS][KB_COLUMNS] = {
     // LAYER 0
     KB_MATRIX_LAYER(
         // unused
         0,
         // left hand
         _esc,       _1, _2, _3, _4, _5, _grave,
         0,          _Q, _D, _R, _W, _B, _tab,
         _backslash, _A, _S, _H, _T, _G,
         _shiftL,    _Z, _X, _M, _C, _V, _guiL,
         0,          0,  0,  0,  _esc,
         // left thumb block
              0, 0,
         0,   0, _altL,
         _bs, 2, _ctrlL,
         // right hand
         _equal, _6, _7, _8, _9,      _0,         _esc,
         _dash,  _J, _F, _U, _P,      _semicolon, 0,
                 _Y, _N, _E, _O,      _I,         _quote,
         _guiR,  _K, _L, 1,  _period, _slash,     _shiftR,
                 _arrowU, _arrowD, _arrowL, _arrowR, 0,
         // right thumb block
         0,      0,
         _altR,  0,      0,
         _ctrlR, _enter, _space
     ),
   #+end_src

   The above snippet is the definition for the first layer and defines the basic
   Workman layout. The =0='s indicate an unused key while the ones with an
   underscore reference a given key code. For example, =_9= refers to the key code
   that a regular USB keyboard emits when you press the =9= key (I'm using the
   short name, the full name is more descriptive: =KEY_9_LeftParenthesis=).

   To implement the symbol layer, I use the comma key as a sticky key, wish
   activates a second layer (for one key press). The definition of the sticky
   keys is straight-forward: You indicate the layer number on the normal layout
   (the =1= in comma position and =2= on the left thumb block in the basic layout
   above).

   In addition to the call to =_kb_layout=, you manage the specific behavior for
   press & release by passing mappings to =_kb_layout_press= and
   =_kb_layout_release=. These mappings are analogous to the one passed to
   =_kb_layout=, but instead of key codes you add references to functions. For the
   activation of the symbol layer, you add references to =lsticky1= or =lsticky2= in
   the press & and release mappings.

   Not all symbols are accessible without modifiers on a regular keyboard, but
   one goal of the dead key approach is to get rid of the modifier. For this to
   work, you can supply a modifier-specific function in the press & release
   mapping. For example, this is just the layout for the left hand for the
   symbol layer:

   #+begin_src c
     0,  0,          0,          0,          0,          0,      0,
     0,  _bracketR,  _bracketR,  _0,         _add_kp,    _2,     0,
     0,  _bracketL,  _bracketL,  _9,         _equal_kp,  _5,
     0,  _comma,     _period,    _backslash, _dash,      _dash,  0,
     0,  0,          0,          0,          0,
   #+end_src

   To produce ={}= rather than =[]= in the third column, the press & release
   mappings contain calls to =kbfun_shift_press_release= (aka =sshprre=) rather than
   the normal =kbfun_press_release= (aka =kprrel=):

   #+begin_src c
    ktrans,	ktrans,		ktrans,		ktrans,		ktrans,		ktrans,		ktrans,
    ktrans,	kprrel,		sshprre,	sshprre,	sshprre,	sshprre,	ktrans,
    ktrans,	kprrel,		sshprre,	sshprre,	sshprre,	sshprre,
    ktrans,	sshprre,	sshprre,	sshprre,	kprrel,		sshprre,	ktrans,
    ktrans,	ktrans,		ktrans,		ktrans,		ktrans,
   #+end_src

   The tedious bit is to keep the corresponding calls to =_kb_layout_press= and
   =_kb_layout_release= for each layer in sync. Otherwise you might see modifier
   keys that remain pressed for no apparent reason. For example, if the press &
   release mappings contain different function references, one to =kprrel= and the
   other to =sshprre=, then the shift modifier would not get released properly.
   Keeping the different invocations in sync is a bit tedious as all information
   is passed in a single call where position defines the meaning of a value and
   you only get arity compiler warnings. But your favorite editor might be able
   to help you with that ;)

   For reference my full layout is available [[https://github.com/fgeller/ergodox-firmware/blob/master/src/keyboard/ergodox/layout/workman-dead-mod.c][here]].

* § [[file:2014/pipes.html][scala pipes]]

  I was looking for an operator to make the following easier to read:

#+begin_src scala
  val hans = Person("Herbert", "Fischer", new java.util.Date(now - (23 * MilliSecondsInYear)))
  val withAge = addAge(hans)
  val withAgeAndFullName = addFullName(withAge)
#+end_src

More specifically, the goal is to fill in optional fields based on initially
populated fields. In this case the mandatory fields are =firstName=, =lastName= and
=birthDate= and we derive the =age= and =fullName=:

#+begin_src scala
  val MilliSecondsInYear = 1000 * 60 * 60 * 24 * 365L
  def now = System.currentTimeMillis

  case class Person(
    firstName: String,
    lastName: String,
    birthDate: java.util.Date,
    age: Option[Long] = None,
    fullName: Option[String] = None)

  def addFullName(person: Person) = person.copy(fullName = Some(s"${person.firstName} ${person.lastName}"))
  def addAge(person: Person) = person.copy(age = Some((now - person.birthDate.getTime) / MilliSecondsInYear))
#+end_src

The full example I was looking at had about ten chained function
invocations. Inserting intermediate results led to redundant names as in the
example above and nesting the function invocations felt hard to read as you have
to read the expressions from the inside out:

#+begin_src scala
  val withAgeAndFullName = addFullName(addAge(hans))
#+end_src

My preferred solution was imitating pipes like this:

#+begin_src sh
  ls | sort | uniq -c
#+end_src

So ideally we could write:

#+begin_src scala
  val withAgeAndFullName = hans | addAge | addFullName
#+end_src

But that's the bitwise OR. The alternative I've seen is the following:

#+begin_src scala
  val withAgeAndFullName = hans |> addAge |> addFullName
#+end_src

Rather than including a library for this, we can try this ourselves. First, we
need to pimp objects with our operator:

#+begin_src scala
  class PimpAny[A](any: A) {
    def |>[B](fun: A ⇒ B): B = fun(any)
  }
#+end_src

And add an implicit conversion to make this available:

#+begin_src scala
  implicit def pimpAnyWithPipeOperator[A](any: A) = new PimpAny(any)
#+end_src

We can be even more concise and combine the wrapping class and the
implicit conversion via syntactic sugar in an implicit class:

#+begin_src scala
  implicit class PimpAnyWithPipeOperator[A](any: A) {
    def |>[B](fun: A ⇒ B): B = fun(any)
  }
#+end_src

And we're done -- fun practice to learn about implicit classes. :)

Full REPL example with pipes:

#+begin_src scala
  implicit class PimpAnyWithPipeOperator[A](any: A) {
    def |>[B](fun: A ⇒ B): B = fun(any)
  }

  val MilliSecondsInYear = 1000 * 60 * 60 * 24 * 365L

  case class Person(
    firstName: String,
    lastName: String,
    birthDate: java.util.Date,
    age: Option[Long] = None,
    fullName: Option[String] = None)

  def now = System.currentTimeMillis

  def addFullName(person: Person): Person =
    person.copy(fullName = Some(s"${person.firstName} ${person.lastName}"))

  def addAge(person: Person): Person =
    person.copy(age = Some((now - person.birthDate.getTime) / MilliSecondsInYear))

  val hans = Person("Herbert", "Fischer", new java.util.Date(now - (23 * MilliSecondsInYear)))
  val withAgeAndFullName = hans |> addAge |> addFullName
#+end_src

* § [[file:2014/tree.html][tree]]

  #+ATTR_HTML: :alt tree :title tree
  [[file:../img/a/P6082095.jpg]]

* § [[file:2014/leaving.html][leaving]]

  #+ATTR_HTML: :alt leaving :title leaving
  [[file:../img/a/P3120694.jpg]]

* § [[file:2014/black-swan.html][black swan]]
* § [[file:2014/move.html][move]]
* § [[file:./2014/up-or-down.html][up or down?]]
* § [[file:./2014/my-world.html][my world]]
* § [[file:./2014/2014-04-28.html][2014-04-28]]
* § [[file:./2014/emacs-lisp-scala.html][emacs lisp + scala]]
* § [[file:./2014/2014-04-13.html][2014-04-13]]
* § [[file:./2014/orange.html][orange]]
* § [[file:./2014/2014-04-02.html][2014-04-02]]
* § [[file:./2014/going-out.html][going out]]
* § [[file:./2014/spot-of-green-ii.html][spot of green II]]
* § [[file:./2014/2014-03-22.html][2014-03-22]]
* § [[file:./2014/2014-03-17.html][2014-03-17]]
* § [[file:./2014/emacs-scala.html][emacs + scala]]
* § [[file:./2014/spot-of-green.html][spot of green]]
* § [[file:./2014/2014-03-01.html][2014-03-01]]
