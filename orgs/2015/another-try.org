#+OPTIONS: html-link-use-abs-url:nil html-postamble:t html-preamble:t
#+OPTIONS: html-scripts:nil html-style:nil html5-fancy:nil
#+OPTIONS: toc:0 num:nil ^:{}
#+HTML_CONTAINER: div
#+HTML_DOCTYPE: xhtml-strict
#+TITLE: another try

One thing I really enjoyed when I started using Scala, is the consistency that
you find across some interfaces in the standard library.


It is a bit confusing initially to learn to  the names =map= and
=flatMap= from lists and also apply them to other concepts like an =Option= or a
=Future=.

While it's maybe hard to let go of the name and consider =map= and =flatMap= as
operations that aren't only applicable to lists, it paid off from me. You end up
applying the same concept confidently in different scenarios and I learned to
appreciate the hints these names where then giving me when reading as well.

Learned to appreciate =map= and =flatmap=, but also =foreach= and =andThen=.


Translating for comprehension
http://docs.scala-lang.org/tutorials/FAQ/yield.html


I was looking for an operator to make the following easier to read:

#+begin_src scala
  val hans = Person("Herbert", "Fischer", new java.util.Date(now - (23 * MilliSecondsInYear)))
  val withAge = addAge(hans)
  val withAgeAndFullName = addFullName(withAge)
#+end_src

More specifically, the goal is to fill in optional fields based on initially
populated fields. In this case the mandatory fields are =firstName=, =lastName= and
=birthDate= and we derive the =age= and =fullName=:

#+begin_src scala
  val MilliSecondsInYear = 1000 * 60 * 60 * 24 * 365L
  def now = System.currentTimeMillis

  case class Person(
    firstName: String,
    lastName: String,
    birthDate: java.util.Date,
    age: Option[Long] = None,
    fullName: Option[String] = None)

  def addFullName(person: Person) = person.copy(fullName = Some(s"${person.firstName} ${person.lastName}"))
  def addAge(person: Person) = person.copy(age = Some((now - person.birthDate.getTime) / MilliSecondsInYear))
#+end_src

The full example I was looking at had about ten chained function
invocations. Inserting intermediate results led to redundant names as in the
example above and nesting the function invocations felt hard to read as you have
to read the expressions from the inside out:

#+begin_src scala
  val withAgeAndFullName = addFullName(addAge(hans))
#+end_src

My preferred solution was imitating pipes like this:

#+begin_src sh
  ls | sort | uniq -c
#+end_src

So ideally we could write:

#+begin_src scala
  val withAgeAndFullName = hans | addAge | addFullName
#+end_src

But that's the bitwise OR. The alternative I've seen is the following:

#+begin_src scala
  val withAgeAndFullName = hans |> addAge |> addFullName
#+end_src

Rather than including a library for this, we can try this ourselves. First, we
need to pimp objects with our operator:

#+begin_src scala
  class PimpAny[A](any: A) {
    def |>[B](fun: A ⇒ B): B = fun(any)
  }
#+end_src

And add an implicit conversion to make this available:

#+begin_src scala
  implicit def pimpAnyWithPipeOperator[A](any: A) = new PimpAny(any)
#+end_src

We can be even more concise and combine the wrapping class and the
implicit conversion via syntactic sugar in an implicit class:

#+begin_src scala
  implicit class PimpAnyWithPipeOperator[A](any: A) {
    def |>[B](fun: A ⇒ B): B = fun(any)
  }
#+end_src

And we're done -- fun practice to learn about implicit classes. :)

Full REPL example with pipes:

#+begin_src scala
  implicit class PimpAnyWithPipeOperator[A](any: A) {
    def |>[B](fun: A ⇒ B): B = fun(any)
  }

  val MilliSecondsInYear = 1000 * 60 * 60 * 24 * 365L

  case class Person(
    firstName: String,
    lastName: String,
    birthDate: java.util.Date,
    age: Option[Long] = None,
    fullName: Option[String] = None)

  def now = System.currentTimeMillis

  def addFullName(person: Person): Person =
    person.copy(fullName = Some(s"${person.firstName} ${person.lastName}"))

  def addAge(person: Person): Person =
    person.copy(age = Some((now - person.birthDate.getTime) / MilliSecondsInYear))

  val hans = Person("Herbert", "Fischer", new java.util.Date(now - (23 * MilliSecondsInYear)))
  val withAgeAndFullName = hans |> addAge |> addFullName
#+end_src
